<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Medical Terminology - Break the Code</title>
   <style>
    :root {
      --bg-gradient: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
      --glass-bg: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.15);
      --accent: #00d4ff;
      --correct: #00ff9d;
      --wrong: #ff4d6d;
      --text: #e0f7ff;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body {
      height:100%; font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg-gradient); color: var(--text);
      overflow:hidden; touch-action: manipulation;
    }
    #ui {
      position: absolute; inset:0;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" /><feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.05 0"/></filter><rect width="100" height="100" filter="url(%23n)" opacity="0.07"/></svg>') repeat,
                  var(--bg-gradient);
      backdrop-filter: blur(1px);
    }
    #overlay { position:absolute; inset:0; pointer-events:none; }
    #questionBox {
      position: absolute; top: 8vh; left: 5vw; right: 5vw;
      background: var(--glass-bg); backdrop-filter: blur(16px);
      border: 1px solid var(--glass-border); border-radius: 24px;
      padding: 24px 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      text-align: center; font-size: 1.1rem; line-height: 1.5;
      max-height: 70vh; overflow-y: auto;
    }
    .term { 
      color: var(--accent); 
      font-weight: bold; 
      cursor: pointer; 
      text-decoration: underline; 
      transition: transform 0.2s;
    }
    .term.expanded { 
      font-size: 2rem !important; 
      background: rgba(0,212,255,0.2); 
      border-radius: 12px; 
      padding: 8px 16px !important;
      display: inline-block;
      transform: scale(1.1);
    }
    #pieces { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin: 20px 0; min-height: 60px; }
    .piece {
      background: rgba(255,255,255,0.12); backdrop-filter: blur(8px);
      border: 1px solid var(--glass-border); border-radius: 12px;
      padding: 12px 18px; font-size: 1.2rem; cursor: grab; user-select: none;
      transition: all 0.2s;
    }
    .piece:active { transform: scale(1.1); box-shadow: 0 0 20px var(--accent); }
    .dropzone {
      background: rgba(0,0,0,0.2); border: 2px dashed var(--accent);
      border-radius: 16px; padding: 16px; margin: 12px auto; width: 90%;
      min-height: 80px; display: flex; flex-wrap: wrap; gap: 10px;
      font-weight: bold; color: var(--accent);
    }
    .meaning-pool { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
    .meaning {
      background: rgba(255,255,255,0.1); padding: 10px 16px; border-radius: 20px;
      cursor: grab; transition: 0.2s;
    }
    .meaning.correct { background: var(--correct); color: black; }
    input[type="text"] {
      width: 90%; padding: 14px; margin: 16px auto; display: block;
      background: rgba(255,255,255,0.15); border: none; border-radius: 12px;
      color: white; font-size: 1.1rem; text-align: center;
    }
    button { 
      background: linear-gradient(45deg, #00d4ff, #0095ff);
      border: none; color: white; font-size: 1.2rem; padding: 14px 32px;
      border-radius: 50px; margin: 16px; cursor: pointer; box-shadow: 0 4px 20px rgba(0,212,255,0.4);
      transition: transform 0.15s;
    }
    button:active { transform: scale(0.96); }
    #scoreBoard {
      position: absolute; top: 2vh; right: 4vw; background: var(--glass-bg);
      backdrop-filter: blur(12px); padding: 10px 16px; border-radius: 16px;
      font-size: 1.1rem; border: 1px solid var(--glass-border);
    }
    #particles { position:absolute; inset:0; pointer-events:none; }
    .hidden { display:none !important; }
    @keyframes shake { 0%,100% {transform:translateX(0);} 25%{transform:translateX(-5px);} 75%{transform:translateX(5px);} }
  </style>
</head>
<body>

<canvas id="overlay"></canvas>
<canvas id="particles"></canvas>

<div id="ui">
  <div id="scoreBoard">Score: 0 | Question: 1/10 | Time: 0s</div>
  <div id="questionBox">
    <h2>Welcome!</h2>
    <p>Tap "Start" to get 10 random terms.<br>Use your medical dictionary/notes — no Google!</p>
    <button onclick="startGame()">Start Session</button>
  </div>
</div>

<script>
// ──────────────────────────────────────────────── Data
const allQuestions = [
  // ... (keep all existing questions array unchanged) ...
];

let questions = [], current = 0, score = 0, startTime = null, timerInterval;
const qBox = document.getElementById('questionBox');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const particlesCanvas = document.getElementById('particles');
const pCtx = particlesCanvas.getContext('2d');

function resizeCanvases() {
  overlay.width = particlesCanvas.width = window.innerWidth;
  overlay.height = particlesCanvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvases);
resizeCanvases();

// ──────────────────────────────────────────────── Helpers
function vibrate(ms = 100) {
  if (navigator.vibrate) navigator.vibrate(ms);
}
function successVibe() { vibrate([80, 40, 80]); confettiBurst(); }
function wrongVibe() { vibrate(200); }

function confettiBurst() {
  const colors = ['#00ff9d','#00d4ff','#ffdd00'];
  const w = window.innerWidth || 800; 
  const h = window.innerHeight || 600;
  
  for(let i=0; i<60; i++) {
    const x = Math.random()*w;
    const y = Math.random()*h*0.6;
    const vx = (Math.random()-0.5)*12;
    const vy = -Math.random()*8-4;
    const size = Math.random()*6+3;
    const c = colors[Math.floor(Math.random()*colors.length)];
    let life = 60;
    const anim = () => {
      if(life-- <=0) return;
      pCtx.fillStyle = c;
      pCtx.globalAlpha = life/60;
      pCtx.fillRect(x+vx*(60-life)/10, y+vy*(60-life)/10 + (60-life)**2/100, size, size);
      requestAnimationFrame(anim);
    };
    anim();
  }
  pCtx.globalAlpha = 1;
}

// ──────────────────────── Game Logic
function startGame(isTeacher = false) {
  const urlParams = new URLSearchParams(location.search);
  const teacher = isTeacher || urlParams.get('teacher') === 'true';
  questions = teacher ? allQuestions : [...allQuestions].sort(()=>Math.random()-0.5).slice(0,10);
  current = 0; score = 0; startTime = Date.now();
  if(!teacher) timerInterval = setInterval(updateTimer, 1000);
  nextQuestion();
}

function updateTimer() {
  const t = Math.floor((Date.now() - startTime)/1000);
  document.getElementById('scoreBoard').innerText = `Score: ${score} | Question: ${current+1}/${questions.length} | Time: ${t}s`;
}

function nextQuestion() {
  if(current >= questions.length) {
    clearInterval(timerInterval);
    const t = Math.floor((Date.now() - startTime)/1000);
    qBox.innerHTML = `<h2>Session Complete!</h2>
      <p>Score: ${score} / ${questions.length}</p>
      <p>Time: ${t} seconds</p>
      <button onclick="location.reload()">Play Again</button>`;
    return;
  }
  renderQuestion(questions[current]);
}

function renderQuestion(q) {
  const partsCount = q.answerBreak.split('/').length;
  qBox.innerHTML = `
    <h3>Question ${current+1}/${questions.length}</h3>
    <p>${q.sentence}</p>
    <p>Break "<strong>${q.term || q.sentence.match(/data-term='(.*?)'/)[1]}</strong>" into <strong>${partsCount}</strong> part${partsCount>1?'s':''}.</p>
    <div id="pieces"></div>
    <div id="prefixZone" class="dropzone">Prefix</div>
    <div id="rootZone" class="dropzone">Root / Combining Form</div>
    <div id="suffixZone" class="dropzone">Suffix</div>
    <div id="meaningsZone" class="meaning-pool hidden"></div>
    <input type="text" id="explanation" placeholder="Explain what the condition/term means..." class="hidden"/>
    <button id="submitExp" class="hidden">Submit Explanation</button>
  `;

  const termEl = qBox.querySelector('.term');
  termEl.addEventListener('click', () => {
    termEl.classList.toggle('expanded');
    vibrate(30);
  }, { passive: true });

  if(q.special) {
    const note = document.createElement('p');
    note.style.color = 'var(--accent)';
    note.innerHTML = `Note: Look up "<strong>${q.special}</strong>" in your dictionary (no breaking needed).`;
    qBox.appendChild(note);
  }

  setupSplitting(termEl.innerText, q.answerBreak, q);
}

function setupSplitting(fullTerm, correctBreak, q) {
  const piecesDiv = document.getElementById('pieces');
  const termEl = qBox.querySelector('.term');
  
  let isDragging = false, currentSplits = [], lastX = null, lastY = null;
  const rect = termEl.getBoundingClientRect();
  
  ctx.clearRect(0, 0, overlay.width, overlay.height);
  
  // Touch handlers with passive: false
  termEl.addEventListener('touchstart', e => {
    e.preventDefault();
    isDragging = false;
    currentSplits = [];
    lastX = null;
    lastY = null;
  }, { passive: false });

  termEl.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isDragging) isDragging = true;
    
    const touch = e.touches[0];
    if (lastX !== null) {
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(touch.clientX, touch.clientY);
      ctx.strokeStyle = 'rgba(0,212,255,0.8)';
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.stroke();
    }
    lastX = touch.clientX;
    lastY = touch.clientY;
    
    const xRel = touch.clientX - rect.left;
    const charPos = Math.floor((xRel / rect.width) * fullTerm.length);
    if (charPos > 0 && charPos < fullTerm.length && !currentSplits.includes(charPos)) {
      currentSplits.push(charPos);
      trySplit(charPos, fullTerm, correctBreak, q, piecesDiv, termEl);
    }
  }, { passive: false });

  termEl.addEventListener('touchend', () => {
    if (isDragging) {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      if (currentSplits.length + 1 >= correctBreak.split('/').length) finishBreaking(q);
    }
  }, { passive: false });
}

function trySplit(at, fullTerm, correctBreak, q, piecesDiv, termEl) {
  const attempt = fullTerm.slice(0,at) + '/' + fullTerm.slice(at);
  
  if(correctBreak.startsWith(attempt.split('/').slice(0,-1).join('/'))) {
    vibrate(60);
    const piece = document.createElement('div');
    piece.className = 'piece';
    piece.draggable = true;
    piece.textContent = fullTerm.slice(0,at);
    piece.dataset.part = fullTerm.slice(0,at);
    piece.addEventListener('touchstart', e => dragStart(e, piece), { passive: false });
    piece.addEventListener('mousedown', e => dragStart(e, piece));
    piecesDiv.appendChild(piece);
    termEl.innerHTML = `<span class="term" data-term="${q.term}">${fullTerm.slice(at)}</span>`;
    
    if(fullTerm.slice(at).length === 0) finishBreaking(q);
  } else {
    wrongVibe();
    piecesDiv.style.animation = 'shake 0.4s';
    setTimeout(() => piecesDiv.style.animation = '', 400);
  }
}

function finishBreaking(q) {
  document.querySelectorAll('.piece').forEach(p => {
    p.draggable = true;
    p.addEventListener('touchstart', e => dragStart(e, p), { passive: false });
    p.addEventListener('mousedown', e => dragStart(e, p));
  });

  const pool = document.getElementById('meaningsZone');
  pool.classList.remove('hidden');
  pool.innerHTML = '';
  const shuffled = [...q.meanings].sort(() => Math.random() - 0.5);
  shuffled.forEach(m => {
    const el = document.createElement('div');
    el.className = 'meaning';
    el.textContent = m;
    el.draggable = true;
    el.addEventListener('touchstart', e => dragStart(e, el, true), { passive: false });
    el.addEventListener('mousedown', e => dragStart(e, el, true));
    pool.appendChild(el);
  });

  document.getElementById('explanation').classList.remove('hidden');
  document.getElementById('submitExp').classList.remove('hidden');
  document.getElementById('submitExp').onclick = () => checkExplanation(q);
}

let dragged = null;
function dragStart(e, el, isMeaning=false) {
  dragged = el;
  el.style.opacity = 0.6;
  
  if(e.type.includes('touch')) {
    e.preventDefault();
    const touch = e.touches[0];
    el.dataset.offsetX = touch.clientX - el.getBoundingClientRect().left;
    el.dataset.offsetY = touch.clientY - el.getBoundingClientRect().top;
  } else {
    el.dataset.offsetX = e.offsetX || 0;
    el.dataset.offsetY = e.offsetY || 0;
  }
}

function dragOver(e) {
  e.preventDefault();
}

function drop(e, zone) {
  e.preventDefault();
  if(!dragged) return;
  const isMeaning = dragged.classList.contains('meaning');
  
  if(isMeaning) {
    zone.appendChild(dragged);
    dragged.style.opacity = 1;
    dragged = null;
  } else {
    zone.appendChild(dragged);
    dragged.style.opacity = 1;
    successVibe();
    dragged = null;
  }
}

['prefixZone','rootZone','suffixZone'].forEach(id => {
  const z = document.getElementById(id);
  z.addEventListener('dragover', dragOver);
  z.addEventListener('drop', e => drop(e, z));
  
  z.addEventListener('touchmove', dragOver, { passive: false });
  z.addEventListener('touchend', e => drop(e, z), { passive: false });
});

function checkExplanation(q) {
  const input = document.getElementById('explanation').value.trim().toLowerCase();
  const correct = q.explanation.toLowerCase();
  const keywords = correct.split(' ').filter(w=>w.length>3);
  const matched = keywords.some(kw => input.includes(kw));
  
  if(matched || input.includes(correct)) {
    score++;
    successVibe();
    qBox.innerHTML += `<p style="color:var(--correct); margin-top:16px;">✅ Correct! ${q.explanation}</p>`;
  } else {
    wrongVibe();
    qBox.innerHTML += `<p style="color:var(--wrong); margin-top:16px;">❌ Expected: ${q.explanation}</p>`;
  }
  
  setTimeout(() => {
    current++;
    pCtx.clearRect(0,0, window.innerWidth || 800, window.innerHeight || 600);
    nextQuestion();
  }, 3000);
}

document.addEventListener('touchmove', e => {
  if(dragged) {
    const touch = e.touches[0];
    dragged.style.position = 'absolute';
    dragged.style.left = (touch.clientX - parseFloat(dragged.dataset.offsetX||0)) + 'px';
    dragged.style.top = (touch.clientY - parseFloat(dragged.dataset.offsetY||0)) + 'px';
  }
}, { passive: false });

document.addEventListener('mousemove', e => {
  if(dragged) {
    dragged.style.position = 'absolute';
    dragged.style.left = (e.clientX - parseFloat(dragged.dataset.offsetX||0)) + 'px';
    dragged.style.top = (e.clientY - parseFloat(dragged.dataset.offsetY||0)) + 'px';
  }
});

if(location.search.includes('teacher=true')) {
  qBox.innerHTML += `<p style="color:var(--accent);">Teacher Mode Active — All questions, answers shown.</p>`;
  startGame(true);
}
</script>
</body>
</html>
