```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Anatomy Motion Coach</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@latest"></script>
  <style>
    body {
      margin: 20px;
      font-family: Arial, sans-serif;
      text-align: center;
      overflow: hidden;
    }
    #container {
      position: relative;
      display: inline-block;
      width: 100%;
      max-width: 640px;
      margin: 0 auto;
    }
    #video {
      transform: scaleX(-1);
      width: 100%;
      height: auto;
      border: 3px solid #ccc;
      display: block;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      transform: scaleX(-1);
    }
    #feedback {
      font-size: 1.5em;
      font-weight: bold;
      margin: 10px;
    }
    #instructions {
      background-color: #f0f0f0;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    #startBtn, #toggleCameraBtn, #muscleSelect {
      padding: 10px 20px;
      font-size: 1em;
      margin: 5px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2>Anatomy Motion Coach</h2>
    <p id="instructionText">1. Select a muscle below.<br>2. Tap "Start Camera".<br>3. Use "Toggle Camera" to switch between selfie and rear camera.<br>4. Perform the motion and hold for 2 seconds for feedback!</p>
  </div>

  <select id="muscleSelect">
    <option value="Biceps Brachii">Biceps Brachii</option>
    <option value="Deltoid">Deltoid</option>
    <option value="Latissimus Dorsi">Latissimus Dorsi</option>
    <option value="Triceps Brachii">Triceps Brachii</option>
    <option value="Hamstrings">Hamstrings</option>
    <option value="Quadriceps">Quadriceps</option>
    <option value="Gluteus Maximus">Gluteus Maximus</option>
  </select><br>
  <button id="startBtn">Start Camera</button>
  <button id="toggleCameraBtn" style="display: none;">Toggle Camera</button><br>
  <div id="container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
  </div>
  <div id="feedback">Select a muscle and press "Start Camera"</div>

  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let feedbackDiv = document.getElementById('feedback');
    let muscleSelect = document.getElementById('muscleSelect');
    let instructionText = document.getElementById('instructionText');
    let detector;
    let isPoseCorrect = false;
    let correctPoseStartTime = 0;
    const HOLD_TIME_NEEDED = 2000;
    let currentFacingMode = 'environment';

    const KEYPOINTS = {
      left_shoulder: 5, left_elbow: 7, left_wrist: 9,
      right_shoulder: 6, right_elbow: 8, right_wrist: 10,
      left_hip: 11, left_knee: 13, left_ankle: 15,
      right_hip: 12, right_knee: 14, right_ankle: 16
    };

    const MUSCLES = {
      'Biceps Brachii': {
        instructions: 'Bend either elbow to flex the biceps (60°–100°).',
        check: checkElbowFlexion,
        angleRange: [60, 100],
        keypoints: ['shoulder', 'elbow', 'wrist']
      },
      'Deltoid': {
        instructions: 'Raise either arm sideways (abduction) to 80°–100°.',
        check: checkShoulderAbduction,
        angleRange: [80, 100],
        keypoints: ['hip', 'shoulder', 'elbow']
      },
      'Latissimus Dorsi': {
        instructions: 'Lower either arm from raised position (adduction) to 30°–60°.',
        check: checkShoulderAdduction,
        angleRange: [30, 60],
        keypoints: ['hip', 'shoulder', 'elbow']
      },
      'Triceps Brachii': {
        instructions: 'Straighten either elbow (extension) to 150°–180°.',
        check: checkElbowExtension,
        angleRange: [150, 180],
        keypoints: ['shoulder', 'elbow', 'wrist']
      },
      'Hamstrings': {
        instructions: 'Bend either knee (flexion) to 50°–100°.',
        check: checkKneeFlexion,
        angleRange: [50, 100],
        keypoints: ['hip', 'knee', 'ankle']
      },
      'Quadriceps': {
        instructions: 'Straighten either leg at the knee (extension) to 150°–180°.',
        check: checkKneeExtension,
        angleRange: [150, 180],
        keypoints: ['hip', 'knee', 'ankle']
      },
      'Gluteus Maximus': {
        instructions: 'Extend either hip backward (extension) to 160°–180°.',
        check: checkHipExtension,
        angleRange: [160, 180],
        keypoints: ['shoulder', 'hip', 'knee']
      }
    };

    async function startCamera(facingMode = 'environment') {
      try {
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
        }

        video.setAttribute("playsinline", true);
        video.setAttribute("muted", true);

        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: facingMode, width: { ideal: 640 }, height: { ideal: 480 } },
          audio: false
        });
        video.srcObject = stream;
        currentFacingMode = facingMode;

        video.onloadedmetadata = () => {
          video.play().catch(err => {
            console.error("Video play error:", err);
            feedbackDiv.textContent = "❌ Video playback failed";
            feedbackDiv.style.color = "red";
          });
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          const container = document.getElementById('container');
          container.style.width = `${video.videoWidth}px`;
          container.style.height = `${video.videoHeight}px`;

          console.log(`Video size: ${video.videoWidth}x${video.videoHeight}`);
          if (!detector) {
            initializeBackend();
          } else {
            detectPose();
          }
        };
      } catch (err) {
        console.error("Camera error:", err);
        feedbackDiv.textContent = "❌ Camera access failed: " + err.message;
        feedbackDiv.style.color = "red";
      }
    }

    async function initializeBackend() {
      try {
        await tf.setBackend('webgl');
        console.log("WebGL backend initialized:", tf.getBackend());

        if (!tf.getBackend()) {
          console.warn("WebGL unavailable, falling back to CPU");
          await tf.setBackend('cpu');
          console.log("CPU backend initialized:", tf.getBackend());
        }

        loadPoseDetector();
      } catch (err) {
        console.error("Backend initialization error:", err);
        feedbackDiv.textContent = "❌ Backend initialization failed: " + err.message;
        feedbackDiv.style.color = "red";
      }
    }

    async function loadPoseDetector() {
      try {
        const model = poseDetection.SupportedModels.MoveNet;
        detector = await poseDetection.createDetector(model, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER
        });
        console.log("✅ Pose detector loaded with backend:", tf.getBackend());
        detectPose();
      } catch (err) {
        console.error("Detector error:", err);
        feedbackDiv.textContent = "❌ Pose detector failed to load: " + err.message;
        feedbackDiv.style.color = "red";
      }
    }

    function calculateAngle(a, b, c) {
      let ax = currentFacingMode === 'user' ? canvas.width - a.x : a.x;
      let bx = currentFacingMode === 'user' ? canvas.width - b.x : b.x;
      let cx = currentFacingMode === 'user' ? canvas.width - c.x : c.x;

      const radians = Math.atan2(c.y - b.y, cx - bx) - Math.atan2(a.y - b.y, ax - bx);
      let angle = Math.abs(radians * 180 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }

    async function detectPose() {
      if (!detector) {
        console.warn("Detector not ready");
        requestAnimationFrame(detectPose);
        return;
      }

      try {
        const poses = await detector.estimatePoses(video);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (poses.length > 0) {
          console.log("✅ Pose detected");
          const keypoints = poses[0].keypoints;
          drawSkeleton(keypoints);
          const muscle = MUSCLES[muscleSelect.value];
          muscle.check(keypoints);
        } else {
          feedbackDiv.textContent = "No pose detected!";
          feedbackDiv.style.color = "red";
        }
      } catch (err) {
        console.error("Pose detection error:", err);
        feedbackDiv.textContent = "Pose detection error";
        feedbackDiv.style.color = "red";
      }
      requestAnimationFrame(detectPose);
    }

    function drawSkeleton(keypoints) {
      const muscle = MUSCLES[muscleSelect.value];
      const kpNames = muscle.keypoints;
      const sides = ['left', 'right'];

      sides.forEach(side => {
        const start = KEYPOINTS[`${side}_${kpNames[0]}`];
        const mid = KEYPOINTS[`${side}_${kpNames[1]}`];
        const end = KEYPOINTS[`${side}_${kpNames[2]}`];
        drawLine(keypoints, start, mid);
        drawLine(keypoints, mid, end);

        [start, mid, end].forEach(idx => {
          if (keypoints[idx].score > 0.3) {
            ctx.beginPath();
            ctx.arc(keypoints[idx].x, keypoints[idx].y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
          }
        });
      });
    }

    function drawLine(kp, i, j) {
      if (kp[i].score > 0.3 && kp[j].score > 0.3) {
        ctx.beginPath();
        ctx.moveTo(kp[i].x, kp[i].y);
        ctx.lineTo(kp[j].x, kp[j].y);
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'cyan';
        ctx.stroke();
      }
    }

    function checkElbowFlexion(kp) {
      const arms = [
        { shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], wrist: kp[KEYPOINTS.left_wrist], side: 'left' },
        { shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], wrist: kp[KEYPOINTS.right_wrist], side: 'right' }
      ];
      checkMotion(kp, arms, 'Biceps Brachii', 'elbow');
    }

    function checkShoulderAbduction(kp) {
      const arms = [
        { hip: kp[KEYPOINTS.left_hip], shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], side: 'left' },
        { hip: kp[KEYPOINTS.right_hip], shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], side: 'right' }
      ];
      checkMotion(kp, arms, 'Deltoid', 'shoulder');
    }

    function checkShoulderAdduction(kp) {
      const arms = [
        { hip: kp[KEYPOINTS.left_hip], shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], side: 'left' },
        { hip: kp[KEYPOINTS.right_hip], shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], side: 'right' }
      ];
      checkMotion(kp, arms, 'Latissimus Dorsi', 'shoulder');
    }

    function checkElbowExtension(kp) {
      const arms = [
        { shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], wrist: kp[KEYPOINTS.left_wrist], side: 'left' },
        { shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], wrist: kp[KEYPOINTS.right_wrist], side: 'right' }
      ];
      checkMotion(kp, arms, 'Triceps Brachii', 'elbow');
    }

    function checkKneeFlexion(kp) {
      const legs = [
        { hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], ankle: kp[KEYPOINTS.left_ankle], side: 'left' },
        { hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], ankle: kp[KEYPOINTS.right_ankle], side: 'right' }
      ];
      checkMotion(kp, legs, 'Hamstrings', 'knee');
    }

    function checkKneeExtension(kp) {
      const legs = [
        { hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], ankle: kp[KEYPOINTS.left_ankle], side: 'left' },
        { hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], ankle: kp[KEYPOINTS.right_ankle], side: 'right' }
      ];
      checkMotion(kp, legs, 'Quadriceps', 'knee');
    }

    function checkHipExtension(kp) {
      const legs = [
        { shoulder: kp[KEYPOINTS.left_shoulder], hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], side: 'left' },
        { shoulder: kp[KEYPOINTS.right_shoulder], hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], side: 'right' }
      ];
      checkMotion(kp, legs, 'Gluteus Maximus', 'hip');
    }

    function checkMotion(kp, limbs, muscleName, joint) {
      let bestAngle = null;
      let bestLimb = null;

      for (const limb of limbs) {
        const { side } = limb;
        const points = Object.values(limb).slice(0, 3);
        console.log(`Checking ${side} ${muscleName}: scores=${points.map(p => p.score.toFixed(2)).join(', ')}`);

        if (points.every(p => p.score > 0.3)) {
          const angle = calculateAngle(...points);
          console.log(`${side} ${muscleName} angle: ${angle.toFixed(0)}°`);

          if (!bestAngle || Math.abs(angle - (MUSCLES[muscleName].angleRange[0] + MUSCLES[muscleName].angleRange[1]) / 2) < Math.abs(bestAngle - (MUSCLES[muscleName].angleRange[0] + MUSCLES[muscleName].angleRange[1]) / 2)) {
            bestAngle = angle;
            bestLimb = limb;
          }
        }
      }

      if (bestLimb) {
        const { side } = bestLimb;
        const points = Object.values(bestLimb).slice(0, 3);
        const midPoint = points[1];

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(`Angle (${side} ${joint}): ${bestAngle.toFixed(0)}°`, midPoint.x + 10, midPoint.y);

        if (bestAngle >= MUSCLES[muscleName].angleRange[0] && bestAngle <= MUSCLES[muscleName].angleRange[1]) {
          ctx.beginPath();
          ctx.arc(midPoint.x, midPoint.y, 10, 0, 2 * Math.PI);
          ctx.fillStyle = 'green';
          ctx.fill();

          if (!isPoseCorrect) {
            isPoseCorrect = true;
            correctPoseStartTime = Date.now();
          } else {
            const holdTime = Date.now() - correctPoseStartTime;
            if (holdTime >= HOLD_TIME_NEEDED) {
              feedbackDiv.textContent = `✅ CORRECT! ${muscleName} Motion (${side} ${joint})`;
              feedbackDiv.style.color = "green";
            } else {
              feedbackDiv.textContent = `Hold it... (${(holdTime/1000).toFixed(1)}s)`;
              feedbackDiv.style.color = "orange";
            }
          }
        } else {
          isPoseCorrect = false;
          feedbackDiv.textContent = `Adjust your pose: ${MUSCLES[muscleName].instructions.split('(')[0]}(${MUSCLES[muscleName].angleRange[0]}°–${MUSCLES[muscleName].angleRange[1]}°). Current (${side} ${joint}): ${bestAngle.toFixed(0)}°`;
          feedbackDiv.style.color = "red";
        }
      } else {
        feedbackDiv.textContent = `Make sure your ${joint} is fully visible!`;
        feedbackDiv.style.color = "red";
      }
    }

    muscleSelect.addEventListener('change', () => {
      const muscle = MUSCLES[muscleSelect.value];
      instructionText.innerHTML = `1. Select a muscle below.<br>2. Tap "Start Camera".<br>3. Use "Toggle Camera" to switch between selfie and rear camera.<br>4. ${muscle.instructions} Hold for 2 seconds for feedback!`;
      feedbackDiv.textContent = "Select a muscle and press 'Start Camera'";
      feedbackDiv.style.color = "black";
      isPoseCorrect = false;
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      startCamera(currentFacingMode);
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('toggleCameraBtn').style.display = 'inline-block';
    });

    document.getElementById('toggleCameraBtn').addEventListener('click', () => {
      const newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
      startCamera(newFacingMode);
      document.getElementById('toggleCameraBtn').textContent = `Switch to ${newFacingMode === 'environment' ? 'Selfie' : 'Rear'} Camera`;
    });

    // Initialize instructions
    instructionText.innerHTML = `1. Select a muscle below.<br>2. Tap "Start Camera".<br>3. Use "Toggle Camera" to switch between selfie and rear camera.<br>4. ${MUSCLES[muscleSelect.value].instructions} Hold for 2 seconds for feedback!`;
  </script>
</body>
</html>
```
