<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anatomy Motion Coach</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.12.0/dist/tf-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.12.0/dist/tf-backend-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu@4.12.0/dist/tf-backend-cpu.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 15px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
    }
    #instructions {
      background: rgba(255,255,255,0.95);
      color: #333;
      padding: 20px;
      border-radius: 16px;
      margin-bottom: 20px;
      text-align: left;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    #instructionText {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 15px 0;
    }
    #startPosition, #finishPosition {
      padding: 12px;
      margin: 10px 0;
      border-radius: 12px;
      font-size: 1rem;
    }
    #startPosition {
      background: #fff3e0;
      border-left: 5px solid #ff9800;
    }
    #finishPosition {
      background: #e8f5e9;
      border-left: 5px solid #4caf50;
    }
    .controls {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    select, button {
      padding: 14px 20px;
      font-size: 1rem;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    select {
      background: white;
      color: #333;
      min-width: 220px;
      border: 2px solid rgba(255,255,255,0.3);
    }
    button {
      background: rgba(255,255,255,0.95);
      color: #333;
      flex: 1;
      max-width: 180px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    }
    #container {
      position: relative;
      width: 100%;
      max-width: 640px;
      margin: 0 auto 20px;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      background: #000;
    }
    #video {
      width: 100%;
      height: auto;
      display: block;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .selfie-mode { transform: scaleX(-1); }
    #feedback {
      font-size: 1.4rem;
      font-weight: 700;
      padding: 20px;
      background: rgba(255,255,255,0.95);
      color: #333;
      border-radius: 16px;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      max-width: 640px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    .status-loading { background: #fff3e0 !important; color: #e65100 !important; }
    .status-good { background: #e8f5e9 !important; color: #2e7d32 !important; }
    .status-warning { background: #fff3e0 !important; color: #f57c00 !important; }
    .status-error { background: #ffebee !important; color: #c62828 !important; }
  </style>
</head>
<body>
  <div id="instructions">
    <h1 style="margin: 0 0 20px 0; font-size: 1.8rem;">üèãÔ∏è Anatomy Motion Coach</h1>
    <p id="instructionText">Select a muscle</p>
    <div id="startPosition">üìç <strong>START:</strong> <span id="startDesc">-</span></div>
    <div id="finishPosition">‚úÖ <strong>FINISH:</strong> <span id="finishDesc">-</span></div>
  </div>

  <div class="controls">
    <select id="muscleSelect">
      <option value="Biceps Brachii">üí™ Biceps Brachii (Arm Flex)</option>
      <option value="Deltoid">ü¶æ Deltoid (Arm Raise)</option>
      <option value="Latissimus Dorsi">ü¶ã Lats (Raise & Lower)</option>
      <option value="Triceps Brachii">ü¶æ Triceps (Arm Extend)</option>
      <option value="Hamstrings">ü¶µ Hamstrings (Leg Curl)</option>
      <option value="Quadriceps">ü¶µ Quads (Leg Extend)</option>
      <option value="Gluteus Maximus">üçë Glutes (Hip Extend)</option>
    </select>
    <button id="startBtn">üé• Start Camera</button>
    <button id="toggleCameraBtn" style="display: none;">üîÑ Switch Camera</button>
  </div>

  <div id="container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
  </div>
  
  <div id="feedback">Select muscle ‚Üí Start Camera</div>

  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');
    let feedbackDiv = document.getElementById('feedback');
    let muscleSelect = document.getElementById('muscleSelect');
    let instructionText = document.getElementById('instructionText');
    let startDesc = document.getElementById('startDesc');
    let finishDesc = document.getElementById('finishDesc');

    let detector;
    let isPoseCorrect = false;
    let correctPoseStartTime = 0;
    const HOLD_TIME_NEEDED = 2000;
    let currentFacingMode = 'environment';
    let frameCounter = 0;
    let loadingAttempts = 0;
    const MAX_ATTEMPTS = 3;

    const KEYPOINTS = {
      left_shoulder: 5, left_elbow: 7, left_wrist: 9,
      right_shoulder: 6, right_elbow: 8, right_wrist: 10,
      left_hip: 11, left_knee: 13, left_ankle: 15,
      right_hip: 12, right_knee: 14, right_ankle: 16
    };

    const MUSCLES = {
      'Biceps Brachii': {
        instructions: 'Flex biceps - bend elbow sharply',
        startPosition: 'Arm straight down by side',
        finishPosition: 'Elbow bent 60-100¬∞ (fist near shoulder)',
        check: checkElbowFlexion, angleRange: [60, 100], keypoints: ['shoulder', 'elbow', 'wrist']
      },
      'Deltoid': {
        instructions: 'Raise arm sideways to shoulder level',
        startPosition: 'Arm relaxed by side',
        finishPosition: 'Arm raised 80-100¬∞ (parallel to ground)',
        check: checkShoulderAbduction, angleRange: [80, 100], keypoints: ['hip', 'shoulder', 'elbow']
      },
      'Latissimus Dorsi': {
        instructions: 'Raise arm overhead ‚Üí pull down to side',
        startPosition: 'Arm straight overhead',
        finishPosition: 'Arm down beside body (30-60¬∞)',
        check: checkShoulderAdduction, angleRange: [30, 60], keypoints: ['hip', 'shoulder', 'elbow']
      },
      'Triceps Brachii': {
        instructions: 'Fully extend/straighten elbow',
        startPosition: 'Elbow bent 90¬∞',
        finishPosition: 'Arm locked straight (150-180¬∞)',
        check: checkElbowExtension, angleRange: [150, 180], keypoints: ['shoulder', 'elbow', 'wrist']
      },
      'Hamstrings': {
        instructions: 'Bend knee - heel to buttock',
        startPosition: 'Leg straight',
        finishPosition: 'Knee bent 50-100¬∞',
        check: checkKneeFlexion, angleRange: [50, 100], keypoints: ['hip', 'knee', 'ankle']
      },
      'Quadriceps': {
        instructions: 'Fully straighten knee/leg',
        startPosition: 'Knee bent',
        finishPosition: 'Leg locked straight (150-180¬∞)',
        check: checkKneeExtension, angleRange: [150, 180], keypoints: ['hip', 'knee', 'ankle']
      },
      'Gluteus Maximus': {
        instructions: 'Kick leg backward (hip extension)',
        startPosition: 'Leg by side',
        finishPosition: 'Leg back 160-180¬∞',
        check: checkHipExtension, angleRange: [160, 180], keypoints: ['shoulder', 'hip', 'knee']
      }
    };

    async function startCamera(facingMode = 'environment') {
      if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

      if (facingMode === 'user') video.classList.add('selfie-mode');
      else video.classList.remove('selfie-mode');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode, width: { ideal: 640 }, height: { ideal: 480 } },
          audio: false
        });
        video.srcObject = stream;
        currentFacingMode = facingMode;

        video.onloadedmetadata = () => {
          video.play();
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          initializeBackend();
        };
      } catch (err) {
        feedbackDiv.textContent = "‚ùå Camera access denied";
        feedbackDiv.className = "status-error";
      }
    }

    async function initializeBackend() {
      try {
        feedbackDiv.textContent = `‚è≥ Loading AI... (${loadingAttempts + 1}/${MAX_ATTEMPTS})`;
        feedbackDiv.className = "status-loading";

        // Backend fallback
        try {
          await tf.setBackend('webgl');
          await tf.ready();
        } catch {
          await tf.setBackend('cpu');
          await tf.ready();
        }

        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
        );

        feedbackDiv.textContent = "‚úÖ AI Ready! Hold pose 2 seconds";
        feedbackDiv.className = "status-good";
        detectPose();

      } catch (err) {
        loadingAttempts++;
        if (loadingAttempts < MAX_ATTEMPTS) {
          setTimeout(initializeBackend, 1500);
        } else {
          feedbackDiv.textContent = "‚ö†Ô∏è AI failed - refresh page";
          feedbackDiv.className = "status-error";
        }
      }
    }

    async function detectPose() {
      if (!detector) {
        requestAnimationFrame(detectPose);
        return;
      }

      frameCounter++;
      if (frameCounter % 3 !== 0) {
        requestAnimationFrame(detectPose);
        return;
      }

      try {
        const poses = await detector.estimatePoses(video);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (poses.length > 0) {
          let keypoints = poses[0].keypoints;
          if (currentFacingMode === 'user') {
            keypoints = keypoints.map(kp => ({ ...kp, x: canvas.width - kp.x }));
          }

          drawSkeleton(keypoints);
          MUSCLES[muscleSelect.value].check(keypoints);
        } else {
          feedbackDiv.textContent = "üëÄ Looking for pose...";
          feedbackDiv.className = "status-warning";
        }
      } catch (err) {
        console.error(err);
      }
      requestAnimationFrame(detectPose);
    }

    function drawSkeleton(keypoints) {
      const muscle = MUSCLES[muscleSelect.value];
      const kpNames = muscle.keypoints;
      ['left', 'right'].forEach(side => {
        const start = KEYPOINTS[`${side}_${kpNames[0]}`];
        const mid = KEYPOINTS[`${side}_${kpNames[1]}`];
        const end = KEYPOINTS[`${side}_${kpNames[2]}`];
        
        drawLine(keypoints, start, mid);
        drawLine(keypoints, mid, end);

        [start, mid, end].forEach(idx => {
          if (keypoints[idx]?.score > 0.3) {
            ctx.beginPath();
            ctx.arc(keypoints[idx].x, keypoints[idx].y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff4444';
            ctx.fill();
          }
        });
      });
    }

    function drawLine(kp, i, j) {
      if (kp[i]?.score > 0.3 && kp[j]?.score > 0.3) {
        ctx.beginPath();
        ctx.moveTo(kp[i].x, kp[i].y);
        ctx.lineTo(kp[j].x, kp[j].y);
        ctx.lineWidth = 5;
        ctx.strokeStyle = '#00ffcc';
        ctx.stroke();
      }
    }

    function calculateAngle(a, b, c) {
      const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180 / Math.PI);
      return angle > 180 ? 360 - angle : angle;
    }

    function checkMotion(kp, limbs, muscleName, joint) {
      let bestAngle = null, bestLimb = null;

      for (const limb of limbs) {
        const points = Object.values(limb).slice(0, 3);
        if (points.every(p => p.score > 0.3)) {
          const angle = calculateAngle(...points);
          if (!bestAngle || Math.abs(angle - (MUSCLES[muscleName].angleRange[0] + MUSCLES[muscleName].angleRange[1]) / 2) < 
              Math.abs(bestAngle - (MUSCLES[muscleName].angleRange[0] + MUSCLES[muscleName].angleRange[1]) / 2)) {
            bestAngle = angle;
            bestLimb = limb;
          }
        }
      }

      if (bestLimb) {
        const points = Object.values(bestLimb).slice(0, 3);
        const midPoint = points[1];
        const range = MUSCLES[muscleName].angleRange;

        // Draw angle
        const text = `${bestAngle.toFixed(0)}¬∞`;
        ctx.font = 'bold 28px Arial';
        const textWidth = ctx.measureText(text).width;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(midPoint.x + 10, midPoint.y - 25, textWidth + 15, 35);
        ctx.fillStyle = '#fff';
        ctx.fillText(text, midPoint.x + 15, midPoint.y);

        // Green circle if correct
        if (bestAngle >= range[0] && bestAngle <= range[1]) {
          ctx.beginPath();
          ctx.arc(midPoint.x, midPoint.y, 15, 0, 2 * Math.PI);
          ctx.fillStyle = '#00ff00';
          ctx.fill();

          if (!isPoseCorrect) {
            isPoseCorrect = true;
            correctPoseStartTime = Date.now();
          } else {
            const holdTime = Date.now() - correctPoseStartTime;
            const progress = Math.min(holdTime / HOLD_TIME_NEEDED, 1);
            
            ctx.fillStyle = `rgba(0,255,0,${progress})`;
            ctx.fillRect(0, 0, canvas.width * progress, 12);

            if (holdTime >= HOLD_TIME_NEEDED) {
              feedbackDiv.textContent = `‚úÖ PERFECT! ${muscleName} COMPLETE`;
              feedbackDiv.className = "status-good";
            } else {
              feedbackDiv.textContent = `‚è≥ Hold ${((HOLD_TIME_NEEDED - holdTime)/1000).toFixed(1)}s`;
              feedbackDiv.className = "status-warning";
            }
          }
        } else {
          isPoseCorrect = false;
          feedbackDiv.textContent = `${range[0]}-${range[1]}¬∞ needed | Now ${bestAngle.toFixed(0)}¬∞`;
          feedbackDiv.className = "status-warning";
        }
      } else {
        feedbackDiv.textContent = "‚ö†Ô∏è Show full limb to camera";
        feedbackDiv.className = "status-warning";
      }
    }

    // All check functions
    const checkFunctions = {
      checkElbowFlexion: kp => checkMotion(kp, [
        { shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], wrist: kp[KEYPOINTS.left_wrist], side: 'L' },
        { shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], wrist: kp[KEYPOINTS.right_wrist], side: 'R' }
      ], 'Biceps Brachii', 'elbow'),
      checkShoulderAbduction: kp => checkMotion(kp, [
        { hip: kp[KEYPOINTS.left_hip], shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], side: 'L' },
        { hip: kp[KEYPOINTS.right_hip], shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], side: 'R' }
      ], 'Deltoid', 'shoulder'),
      checkShoulderAdduction: kp => checkMotion(kp, [
        { hip: kp[KEYPOINTS.left_hip], shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], side: 'L' },
        { hip: kp[KEYPOINTS.right_hip], shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], side: 'R' }
      ], 'Latissimus Dorsi', 'shoulder'),
      checkElbowExtension: kp => checkMotion(kp, [
        { shoulder: kp[KEYPOINTS.left_shoulder], elbow: kp[KEYPOINTS.left_elbow], wrist: kp[KEYPOINTS.left_wrist], side: 'L' },
        { shoulder: kp[KEYPOINTS.right_shoulder], elbow: kp[KEYPOINTS.right_elbow], wrist: kp[KEYPOINTS.right_wrist], side: 'R' }
      ], 'Triceps Brachii', 'elbow'),
      checkKneeFlexion: kp => checkMotion(kp, [
        { hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], ankle: kp[KEYPOINTS.left_ankle], side: 'L' },
        { hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], ankle: kp[KEYPOINTS.right_ankle], side: 'R' }
      ], 'Hamstrings', 'knee'),
      checkKneeExtension: kp => checkMotion(kp, [
        { hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], ankle: kp[KEYPOINTS.left_ankle], side: 'L' },
        { hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], ankle: kp[KEYPOINTS.right_ankle], side: 'R' }
      ], 'Quadriceps', 'knee'),
      checkHipExtension: kp => checkMotion(kp, [
        { shoulder: kp[KEYPOINTS.left_shoulder], hip: kp[KEYPOINTS.left_hip], knee: kp[KEYPOINTS.left_knee], side: 'L' },
        { shoulder: kp[KEYPOINTS.right_shoulder], hip: kp[KEYPOINTS.right_hip], knee: kp[KEYPOINTS.right_knee], side: 'R' }
      ], 'Gluteus Maximus', 'hip')
    };

    Object.keys(MUSCLES).forEach(name => {
      MUSCLES[name].check = checkFunctions[`check${name.replace(/ /g,'')}`];
    });

    // Event Listeners
    document.getElementById('startBtn').onclick = () => {
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('toggleCameraBtn').style.display = 'inline-flex';
      startCamera(currentFacingMode);
    };

    document.getElementById('toggleCameraBtn').onclick = () => {
      currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
      startCamera(currentFacingMode);
    };

    muscleSelect.onchange = () => {
      const muscle = MUSCLES[muscleSelect.value];
      instructionText.textContent = muscle.instructions;
      startDesc.textContent = muscle.startPosition;
      finishDesc.textContent = muscle.finishPosition;
      isPoseCorrect = false;
      feedbackDiv.textContent = "Ready! ‚Üí Start Camera";
      feedbackDiv.className = "";
    };

    // Auto-select first muscle
    muscleSelect.selectedIndex = 0;
    muscleSelect.dispatchEvent(new Event('change'));
  </script>
</body>
</html>
