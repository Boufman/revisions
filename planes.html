<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Anatomy Planes & Directional Terms Coach</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@latest"></script>
  <style>
    body { margin: 20px; font-family: Arial, sans-serif; text-align: center; overflow: hidden; background: #f8f9fa; }
    #container { position: relative; display: inline-block; width: 100%; max-width: 640px; margin: 0 auto; aspect-ratio: 9/16; } /* Adjust for iPhone-like portrait (e.g., 9:16 or 9:19.5; tweak as needed) */
    #video { transform: scaleX(-1); width: 100%; height: 100%; object-fit: cover; border: 3px solid #ccc; display: block; border-radius: 8px; }
    #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; transform: scaleX(-1); }
    #feedback { font-size: 1.4em; font-weight: bold; margin: 15px; padding: 10px; border-radius: 8px; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    #instructions { background: #e9ecef; padding: 15px; border-radius: 8px; margin-bottom: 15px; line-height: 1.5; }
    #termSelect, #startBtn, #toggleCameraBtn { padding: 12px 24px; font-size: 1.1em; margin: 8px; border: none; border-radius: 6px; cursor: pointer; }
    #termSelect { background: #007bff; color: white; }
    #startBtn { background: #28a745; color: white; }
    #toggleCameraBtn { background: #ffc107; color: black; }
    @media (orientation: landscape) {
      #container { aspect-ratio: 16/9; max-height: 480px; } /* Adjust for landscape */
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2>AR Anatomy Planes & Directional Terms Coach</h2>
    <p id="instructionText">Select a mode below.<br>Tap "Start Camera" (selfie best).<br>Point or touch a body part with your hand.<br>Hold steady ~2 seconds for feedback!</p>
  </div>

  <select id="termSelect">
    <option value="medial_lateral">Medial vs Lateral</option>
    <option value="superior_inferior">Superior vs Inferior</option>
    <option value="proximal_distal">Proximal vs Distal</option>
    <option value="anterior_posterior">Anterior vs Posterior (approx)</option>
    <option value="planes">Body Planes (gesture)</option>
  </select><br>

  <button id="startBtn">Start Camera</button>
  <button id="toggleCameraBtn" style="display: none;">Toggle Camera</button><br>

  <div id="container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
  </div>

  <div id="feedback">Select a mode and press "Start Camera"</div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const feedback = document.getElementById('feedback');
    const termSelect = document.getElementById('termSelect');
    const instructionText = document.getElementById('instructionText');
    let detector;
    let isPoseHeld = false;
    let holdStartTime = 0;
    const HOLD_TIME = 1800; // ms
    let currentFacingMode = 'user'; // Start with selfie
    let midlineX = null;

    const KEYPOINTS = {
      nose: 0,
      left_eye: 2, right_eye: 5,
      left_ear: 7, right_ear: 8,
      left_shoulder: 11, right_shoulder: 12,
      left_elbow: 13, right_elbow: 14,
      left_wrist: 15, right_wrist: 16,
      left_hip: 23, right_hip: 24, // Adjust if MoveNet; note: MoveNet hips are 11/12
      left_knee: 25, right_knee: 26,
      left_ankle: 27, right_ankle: 28
    };

    // For MoveNet (17 keypoints)
    const POINTABLE_PARTS = [
      {name: 'nose', idx: 0, midline: true},
      {name: 'left eye', idx: 2}, {name: 'right eye', idx: 5},
      {name: 'left ear', idx: 7}, {name: 'right ear', idx: 8},
      {name: 'left shoulder', idx: 5}, {name: 'right shoulder', idx: 6},
      {name: 'left elbow', idx: 7}, {name: 'right elbow', idx: 8},
      {name: 'left wrist', idx: 9}, {name: 'right wrist', idx: 10},
      {name: 'left hip', idx: 11}, {name: 'right hip', idx: 12},
      {name: 'left knee', idx: 13}, {name: 'right knee', idx: 14},
      {name: 'left ankle', idx: 15}, {name: 'right ankle', idx: 16}
    ];

    async function startCamera(facingMode = 'user') {
      try {
        if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode, width: {ideal: 640}, height: {ideal: 480} }
        });
        video.srcObject = stream;
        currentFacingMode = facingMode;
        video.onloadedmetadata = () => {
          video.play();
          updateCanvasSize();
          if (!detector) initDetector();
          else detectPose();
        };
      } catch (err) {
        feedback.textContent = "Camera error: " + err.message;
        feedback.style.background = "#f8d7da";
      }
    }

    function updateCanvasSize() {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    window.addEventListener('resize', updateCanvasSize);

    async function initDetector() {
      try {
        await tf.setBackend('webgl');
        detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER
        });
        detectPose();
      } catch (err) {
        feedback.textContent = "Detector load failed.";
        feedback.style.background = "#f8d7da";
      }
    }

    function getMirroredX(x) {
      return currentFacingMode === 'user' ? canvas.width - x : x;
    }

    async function detectPose() {
      if (!detector) return requestAnimationFrame(detectPose);
      try {
        const poses = await detector.estimatePoses(video);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (poses.length > 0) {
          const kp = poses[0].keypoints;
          drawSkeleton(kp);
          checkIndication(kp);
          // Update midline
          const ls = kp[5], rs = kp[6]; // MoveNet shoulders
          if (ls?.score > 0.4 && rs?.score > 0.4) {
            midlineX = (getMirroredX(ls.x) + getMirroredX(rs.x)) / 2;
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(midlineX, 0);
            ctx.lineTo(midlineX, canvas.height);
            ctx.strokeStyle = 'rgba(0,123,255,0.6)';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);
          }
        } else {
          feedback.textContent = "No body detected — face camera";
          feedback.style.background = "#fff3cd";
        }
      } catch (err) {}
      requestAnimationFrame(detectPose);
    }

    function drawSkeleton(kp) {
      const pairs = [[5,7],[7,9], [6,8],[8,10], [11,13],[13,15], [12,14],[14,16], [11,12],[5,6]];
      pairs.forEach(([a,b]) => {
        if (kp[a]?.score > 0.3 && kp[b]?.score > 0.3) {
          ctx.beginPath();
          ctx.moveTo(getMirroredX(kp[a].x), kp[a].y);
          ctx.lineTo(getMirroredX(kp[b].x), kp[b].y);
          ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.stroke();
        }
      });
      kp.forEach(p => {
        if (p?.score > 0.3) {
          ctx.beginPath();
          ctx.arc(getMirroredX(p.x), p.y, 6, 0, 2*Math.PI);
          ctx.fillStyle = 'lime'; ctx.fill();
        }
      });
    }

    function findClosestPart(wrist, kp) {
      let closest = null, minDist = Infinity;
      POINTABLE_PARTS.forEach(part => {
        const p = kp[part.idx];
        if (p?.score > 0.35) {
          const d = Math.hypot(getMirroredX(wrist.x) - getMirroredX(p.x), wrist.y - p.y);
          if (d < minDist && d < 120) {
            minDist = d; closest = {part, kp: p, dist: d};
          }
        }
      });
      return closest;
    }

    function checkIndication(kp) {
      const mode = termSelect.value;
      const wrists = [kp[9], kp[10]].filter(w => w?.score > 0.4);
      if (wrists.length === 0) return;

      let pointingWrist = wrists[0];
      if (wrists.length > 1) pointingWrist = wrists.reduce((a,b) => (a.y < b.y ? a : b));

      const closest = findClosestPart(pointingWrist, kp);
      if (!closest || !midlineX) return;

      const {part, kp: targetKp} = closest;
      const tx = getMirroredX(targetKp.x);
      const isLeftSide = tx < midlineX;
      const distToMid = Math.abs(tx - midlineX);

      let result = '', color = 'orange', bg = '#fff';

      if (mode === 'medial_lateral') {
        const isMedial = distToMid < 60;
        result = isMedial ? `${part.name} is near midline → **medial**` : `${part.name} is on ${isLeftSide ? 'left' : 'right'} side → **lateral**`;
        color = isMedial ? 'green' : 'blue';
      } else if (mode === 'superior_inferior') {
        const headY = kp[0]?.y || 0;
        const isSuperior = targetKp.y < headY + 100;
        result = isSuperior ? `${part.name} is **superior** (higher)` : `${part.name} is **inferior** (lower)`;
        color = isSuperior ? 'purple' : 'teal';
      } else if (mode === 'proximal_distal') {
        const isProximal = ['shoulder','hip'].some(s => part.name.includes(s));
        result = isProximal ? `${part.name} is **proximal** (closer to torso)` : `${part.name} is **distal** (farther from torso)`;
        color = isProximal ? 'indigo' : 'brown';
      } else if (mode === 'anterior_posterior') {
        result = "Anterior/posterior hard in 2D — try palm forward (anterior).";
        color = 'gray';
      } else if (mode === 'planes') {
        result = "Try gestures: vertical slice down center = sagittal; horizontal = transverse; side-to-side = frontal.";
        color = 'darkgreen';
      }

      ctx.beginPath();
      ctx.arc(getMirroredX(targetKp.x), targetKp.y, 20, 0, 2*Math.PI);
      ctx.strokeStyle = color; ctx.lineWidth = 5; ctx.stroke();
      ctx.fillStyle = color + '33'; ctx.fill();

      if (result) {
        if (!isPoseHeld) {
          isPoseHeld = true;
          holdStartTime = Date.now();
        }
        const held = Date.now() - holdStartTime;
        if (held >= HOLD_TIME) {
          feedback.innerHTML = `✅ Held! ${result}<br>(${part.name} indicated)`;
          feedback.style.background = '#d4edda';
          feedback.style.color = 'darkgreen';
        } else {
          feedback.innerHTML = `Hold... ${(held/1000).toFixed(1)}s<br>${result}`;
          feedback.style.background = '#fff3cd';
        }
      } else {
        isPoseHeld = false;
        feedback.textContent = "Point clearer — try shoulder, knee, ear...";
        feedback.style.background = "#fff";
      }
    }

    termSelect.addEventListener('change', () => {
      const mode = termSelect.value;
      let instr = "";
      if (mode === 'medial_lateral') instr = "Point at a part — is it medial (close to center) or lateral (off to side)? Hold 2s.";
      else if (mode === 'superior_inferior') instr = "Point up/down body — superior = toward head, inferior = toward feet.";
      else if (mode === 'proximal_distal') instr = "Point limb parts — proximal = closer to body, distal = farther (hand/foot).";
      else if (mode === 'anterior_posterior') instr = "Show front/back — limited in 2D; palm forward = anterior.";
      else if (mode === 'planes') instr = "Gesture planes: vertical midline = sagittal; horizontal cut = transverse; side-to-side = frontal/coronal.";
      instructionText.innerHTML = `1. Select mode.<br>2. Start Camera (selfie best).<br>3. ${instr}<br>4. Hold pose for feedback!`;
      feedback.textContent = "Ready — point and hold!";
      feedback.style.background = "#fff";
      isPoseHeld = false;
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      startCamera(currentFacingMode);
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('toggleCameraBtn').style.display = 'inline-block';
    });

    document.getElementById('toggleCameraBtn').addEventListener('click', () => {
      const newMode = currentFacingMode === 'user' ? 'environment' : 'user';
      startCamera(newMode);
    });

    // Kick off
    termSelect.dispatchEvent(new Event('change'));
  </script>
</body>
</html>
